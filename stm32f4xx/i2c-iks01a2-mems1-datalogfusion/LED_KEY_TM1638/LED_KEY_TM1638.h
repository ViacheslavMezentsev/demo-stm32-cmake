/*
  ******************************************************************************
  * @file 			( фаил ):   LED_KEY_TM1638.h
  * @brief 		( описание ):  	
  ******************************************************************************
  * @attention 	( внимание ):	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com
  ******************************************************************************
*/
#ifndef _LED_KEY_TM1638_H
#define _LED_KEY_TM1638_H

#ifdef __cplusplus
extern "C" {
#endif

// Обязательно нужен #include "main.h"
// чтоб отдельно не подключать файлы связанные с МК и стандартными библиотеками
#include <string.h>
#include "main.h"

/* 
  настройки в CubeMX:
  
  включаем SPI в режиме полудуплексный ( Half-Duplex Master )( по одному проводу и прием и передача )
  меняем порядок бит отправки FirstBits -> LSB First
  скорость ставим небольшую не более 1 МБит/с
  ставим CPOL -> High 
  ставимCPHA -> 2 Edge
  
  распиновка и подключение:
  
  интерфейс: полудуплексный SPI. ( Half-Duplex Master ) ( по одному проводу и прием и передача )
  
  VCC	-	+5V ( разбег не более 10% )
  GND	-	GND
  STB	-	chip select ( выбор устройства )
  CLK	-	clock ( линия тактирования ) SCK
  DIO	-	data in/out (вход и выход ) MOSI
  
  описание принципа работы модуля:
  Данная микросхема это контроллер семисегментного дисплея (максимум 10 знакомест) и клавиатуры (максимум 8х3),
  микросхема имеет внутреннюю память на 16 байт. 
  Каждый байт отвечает за отображение одного символа или светодиода (зависит от разводки платы).
  В моем случае, 8 не четных байт отвечали за цифры на LED-дисплеях. 
  А младший бит каждого четного байта отвечал за 8 светодиодов. 
  + есть доступный для чтения 32-битный регистр, в котором храниться состояние кнопок. 
  + есть байт настроек.
  
  Управляется микросхема довольно легко. Есть всего три типа команд:
	команды управления 	0х8Х
	команды данных 		0х4Х
	команды адреса 		0хСХ
	

  Управлять тут можно целыми двумя параметрами: яркостью и включением отображения. 
  Для этого используется младшая половина байта. 
  Первые  три отведены на яркость и четвертый на управление включением. 
  Соответственно, у яркости 8 градаций. 
  Для включения микросхемы необходимо отправить любую из следующих команд:
	0x88 	Отображение ВКЛ, ширина шим яркости 1/16
	0x89 	Отображение ВКЛ, ширина шим яркости 2/16
	0x8A	Отображение ВКЛ, ширина шим яркости 4/16
	0x8B	Отображение ВКЛ, ширина шим яркости 10/16 
	0x8C	Отображение ВКЛ, ширина шим яркости 11/16
	0x8D	Отображение ВКЛ, ширина шим яркости 12/16
	0x8E	Отображение ВКЛ, ширина шим яркости 13/16
	0x8F	Отображение ВКЛ, ширина шим яркости 14/16
  Для отключения достаточно послать любую из вышеперечисленных команд с обнуленным 3 битом.
	
  После включения можно отправлять и читать данные в/из регистры микросхемы. 
  Для выбора необходимого действия с регистрами служит команда 0x4X; 
  Как и в предыдущей команде, за все отвечает младшая половина байта, а именно 1 и 2 биты.
	1-й бит: 1 - чтение /  0 - запись
	2-й бит: 1 - фиксированный адрес /  0 - автоинкремент адреса

	0x40	Запись, автоинкремент адреса
	0x44	Запись, фиксированный адрес
	0x42	Чтение

	Запись в микросхему возможна в режиме:
	1) фиксированного адреса (команда 0x44): каждый раз сначала передается адрес ячейки памяти, потом байт данных
	2) автоувеличения адреса (команда 0x40): каждый раз сначала передается адрес ячейки памяти, потом несколько байт данных (до 16-ти). Каждый следующий байт пишется в следующую ячейку.

	Управление включением-выключением и яркостью задается командой: 0x80 с параметрами — битами:
	1) Включение выключение задается установкой/сбросом 3-го бита.
	2) Яркость задается от 0 до 7 — 3-мя младшими битами.

	Запись в микросхему состоит из минимум 2-х байт:
	1) Задает адрес записи (или начала записи, если задан режим автоувеличения адреса): 0xC0 + адрес 0-15.
	чтобы удобнее было двигаться от 0 до 16 в одном случае нам нужны четные а в другом нечетные
	поэтому для светодиодов начальный адрес будет 0xC1 ( 0xC0 + 1 сдвиг на 1 разряд ) а для семисегментных индикаторов 0xC0
	2) Собственно байт данных.

	Чтение клавиатуры состоит из 2-х этапов:
	1) Отправки команды чтения клавиатуры: 0x42.
	2) Чтения 32 бит данных.	
*/

//==== указываем порт SPI====================================================

#define TM1638_SPI_HAL hspi3

//=== указываем порты ( если в кубе назвали их STB то тогда нечего указывать не нужно )
#if defined( STB_GPIO_Port )
#else
#define STB_GPIO_Port SPI3_STB_GPIO_Port
#define STB_Pin       SPI3_STB_Pin
#endif

/* Functions prototypes ----------------------------------------------*/

extern SPI_HandleTypeDef TM1638_SPI_HAL;
extern uint8_t num_mas[];

typedef enum
{
    LED_OFF,
    LED_ON
} LedStatus;

/*
	* @brief	 ( описание ):  инициализация дисплея
	* @param	( параметры ):	яркость подсветки от 0 до 7 ( светодиодов и цифр )
	* @return  ( возвращает ):	
*/
void TM1638_init( uint8_t brightness );

/*
	* @brief	 ( описание ):  включение и выключение светодиодов
	* @param	( параметры ):	первый - номер светодиода от 1 до 8
								второй - состояние LED_OFF или LED_ON
	* @return  ( возвращает ):	
*/
void TM1638_Led_OnOff( uint8_t led, LedStatus status );


/*
	* @brief	 ( описание ):  выключаем все светодиоды
	* @param	( параметры ):	
	* @return  ( возвращает ):	
*/
void TM1638_Clear_Led( void );

/*
	* @brief	 ( описание ):  выключаем все семисегментные индикаторы
	* @param	( параметры ):	
	* @return  ( возвращает ):	
*/
void TM1638_Clear_SevenSegment( void );


/*
	* @brief	 ( описание ):  очищаем все полностью и светодиоды и семисегментные индикаторы
	* @param	( параметры ):	
	* @return  ( возвращает ):	
*/
void TM1638_Clear_All( void );


/*
	* @brief	 ( описание ):  функция формирует одно разрядное число ( 1 цифру )
								в указано разряде ( можно совместно включить точку )
	* @param	( параметры ):	1- позиция ( разряд ) где отобразить значение от 1 до 8
								2- сама цифра от 0 до 9 ( если нужен знак минус то ставим 11 )
								3- точка ( 1 включить,  0 выключить )
	* @return  ( возвращает ):	
*/
void TM1638_sendOneDigit( uint8_t pos, uint8_t digit, uint8_t dot );


/*
	* @brief	 ( описание ):  функция для отображения любого числа на дисплее
	* @param	( параметры ):	строка которую нужно отобразить :
								символы цифры от 0 до 9 
								знак минус ( может быть не один )
								знак точка ( может быть не один )
								Например: "-10.56" "0.56" "-2 -2.3" "1.2.3.4." "-23-" и т.д
	* @return  ( возвращает ):	
*/
void TM1638_sendNumber( char* num );


/*
	* @brief	 ( описание ):  функция для отображения INT целочисленного числа на дисплее
	* @param	( параметры ):	число целочисленное :
								цифры от -999 9999 до 9999 9999 
	* @return  ( возвращает ):	
*/
void TM1638_sendNumberInt( int32_t num );


/*
	* @brief	 ( описание ):  функция чтения кнопок
	* @param	( параметры ):	
	* @return  ( возвращает ):	1 байт каждый бит соответствует порядковому номеру кнопки
								1- нажата 0- не нажата
*/
uint8_t TM1638_readKey( void );


#ifdef __cplusplus
}
#endif

#endif
